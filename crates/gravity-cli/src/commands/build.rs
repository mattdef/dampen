//! Build command - generates production Rust code from Gravity UI files

use gravity_core::{parse, generate_application, validate_handlers, HandlerSignature};
use std::fs;
use std::path::{Path, PathBuf};

/// Build command arguments
#[derive(clap::Args)]
pub struct BuildArgs {
    /// Input directory containing .gravity files (default: ui/)
    #[arg(short, long, default_value = "ui")]
    input: String,

    /// Output file for generated code (default: src/ui_generated.rs)
    #[arg(short, long, default_value = "src/ui_generated.rs")]
    output: String,

    /// Model struct name (default: Model)
    #[arg(long, default_value = "Model")]
    model: String,

    /// Message enum name (default: Message)
    #[arg(long, default_value = "Message")]
    message: String,

    /// Verbose output
    #[arg(short, long)]
    verbose: bool,
}

/// Execute the build command
pub fn execute(args: &BuildArgs) -> Result<(), String> {
    if args.verbose {
        eprintln!("Building from {} to {}", args.input, args.output);
    }

    // Find all .gravity files
    let input_dir = PathBuf::from(&args.input);
    if !input_dir.exists() {
        return Err(format!("Input directory '{}' does not exist", args.input));
    }

    let gravity_files = find_gravity_files(&input_dir);
    if gravity_files.is_empty() {
        return Err(format!("No .gravity files found in '{}'", args.input));
    }

    if args.verbose {
        eprintln!("Found {} .gravity files", gravity_files.len());
    }

    // Generate code from all files
    let generated_code = generate_code_from_files(
        &gravity_files,
        &args.model,
        &args.message,
        args.verbose,
    )?;

    // Write to output file
    let output_path = PathBuf::from(&args.output);
    if let Some(parent) = output_path.parent() {
        fs::create_dir_all(parent).map_err(|e| format!("Failed to create output directory: {}", e))?;
    }

    fs::write(&output_path, generated_code).map_err(|e| format!("Failed to write output: {}", e))?;

    if args.verbose {
        eprintln!("Generated code written to {}", output_path.display());
    }

    eprintln!("Build successful!");
    Ok(())
}

/// Find all .gravity files recursively
fn find_gravity_files(dir: &Path) -> Vec<PathBuf> {
    let mut files = Vec::new();
    
    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.filter_map(|e| e.ok()) {
            let path = entry.path();
            
            if path.is_dir() {
                files.extend(find_gravity_files(&path));
            } else     if path.extension().is_some_and(|ext| ext == "gravity") {
                files.push(path);
            }
        }
    }
    
    files
}

/// Generate Rust code from multiple .gravity files
fn generate_code_from_files(
    files: &[PathBuf],
    model_name: &str,
    message_name: &str,
    verbose: bool,
) -> Result<String, String> {
    let mut code = String::new();
    
    // Add header
    code.push_str("//! Auto-generated UI code\n");
    code.push_str("//! DO NOT EDIT - Generated by `gravity build`\n\n");
    code.push_str("use gravity_core::{parse, generate_application, HandlerSignature};\n\n");
    
    // For now, we'll generate a single combined function
    // In a full implementation, we'd parse handler signatures from a separate file
    if files.len() > 1 {
        eprintln!("Warning: Multiple .gravity files found. Using first file for generation.");
    }
    
    // Use the first file for now
    let main_file = &files[0];
    let content = fs::read_to_string(main_file)
        .map_err(|e| format!("Failed to read {}: {}", main_file.display(), e))?;
    
    if verbose {
        eprintln!("Parsing {}", main_file.display());
    }
    
    // Parse the XML
    let doc = parse(&content).map_err(|e| format!("Parse error: {}", e))?;
    
    // For now, use empty handlers (in a full implementation, these would be discovered)
    // In production, this would parse handler signatures from a separate file or derive them
    let handlers: Vec<HandlerSignature> = vec![];
    
    // Skip validation for now since we don't have handler signatures yet
    
    // Generate code
    let output = generate_application(&doc, model_name, message_name, &handlers)
        .map_err(|e| format!("Code generation error: {}", e))?;
    
    code.push_str(&output.code);
    
    // Add warnings if any
    if !output.warnings.is_empty() {
        for warning in &output.warnings {
            eprintln!("Warning: {}", warning);
        }
    }
    
    Ok(code)
}
