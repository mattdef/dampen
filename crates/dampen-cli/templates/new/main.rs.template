//! {{PROJECT_NAME}} - A Dampen UI application
//!
//! This application demonstrates the dual-mode architecture:
//!
//! ## Development Mode (Interpreted)
//! Run with: `cargo run` or `dampen run`
//! - Fast compilation and iteration
//! - Runtime XML parsing with hot-reload support
//! - State preservation during UI changes
//!
//! ## Production Mode (Codegen)
//! Build with: `cargo build --release` or `dampen build --release`
//! - Compile-time code generation
//! - Zero runtime overhead
//! - Optimal performance for deployments
//!
//! The application code is identical in both modes - the mode is selected
//! automatically based on the feature flags set in Cargo.toml.

mod ui;

use dampen_core::AppState;
use dampen_iced::{DampenWidgetBuilder, HandlerMessage};
use iced::{Element, Task};

#[derive(Clone, Debug, PartialEq)]
enum CurrentView {
    Window,
}

/// Main application state wrapper
struct DampenApp {
    current_view: CurrentView,
    window_state: AppState<ui::window::Model>,
}

/// Dispatch a handler to the current view
fn dispatch_handler(app: &mut DampenApp, handler_name: &str, value: Option<String>) {
    let (model, registry) = match app.current_view {
        CurrentView::Window => (
            &mut app.window_state.model as &mut dyn std::any::Any,
            &app.window_state.handler_registry,
        ),
    };
    registry.dispatch(handler_name, model, value);
}

/// Update function
fn update(app: &mut DampenApp, message: HandlerMessage) -> Task<HandlerMessage> {
    match message {
        HandlerMessage::Handler(handler_name, value) => match handler_name.as_str() {
            _ => dispatch_handler(app, &handler_name, value),
        },
    }
    Task::none()
}

/// View function using DampenWidgetBuilder
fn view(app: &DampenApp) -> Element<'_, HandlerMessage> {
    DampenWidgetBuilder::from_app_state(&app.window_state).build()
}

/// Initialize the application
fn init() -> (DampenApp, Task<HandlerMessage>) {
    (
        DampenApp {
            current_view: CurrentView::Window,
            window_state: ui::window::create_app_state(),
        },
        Task::none(),
    )
}

pub fn main() -> iced::Result {
    iced::application(init, update, view).run()
}
