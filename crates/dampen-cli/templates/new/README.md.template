# {{PROJECT_NAME}}

A Dampen UI application - build declarative UIs with XML and Rust!

## Quick Start

Run the application:

```bash
cargo run
```

This will open a window with your UI. Click the button to see bindings in action!

## Project Structure

```
{{PROJECT_NAME}}/
â”œâ”€â”€ Cargo.toml              # Project dependencies
â”œâ”€â”€ README.md               # This file
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs             # Application entry point
â”‚   â””â”€â”€ ui/
â”‚       â”œâ”€â”€ mod.rs          # UI module
â”‚       â”œâ”€â”€ window.rs       # UI model and handlers
â”‚       â””â”€â”€ window.dampen   # Declarative UI definition (XML)
â””â”€â”€ tests/
    â””â”€â”€ integration.rs      # Integration tests
```

## Understanding the Code

### UI Definition (`src/ui/window.dampen`)

The UI is defined declaratively in XML:

```xml
<dampen>
    <column padding="40" spacing="20">
        <text value="Hello, Dampen!" size="32" weight="bold" />
        <button label="Click me!" on_click="greet" />
        <text value="{message}" size="24" />
    </column>
</dampen>
```

- **Root element**: `<dampen>` wraps the entire UI
- **Bindings**: `{message}` automatically displays the `message` field from your model
- **Handlers**: `on_click="greet"` connects the button to the `greet` function
- **Layout**: Use `<column>` and `<row>` to arrange widgets

### UI Module (`src/ui/window.rs`)

The UI module defines your model and handlers using the auto-loading pattern:

```rust
#[derive(Default, UiModel, Serialize, Deserialize, Clone, Debug)]
pub struct Model {
    pub message: String,
}

#[dampen_ui("window.dampen")]
mod _app {}

pub fn create_app_state() -> AppState<Model> {
    let document = _app::document();
    let handler_registry = create_handler_registry();
    AppState::with_handlers(document, handler_registry)
}

pub fn create_handler_registry() -> HandlerRegistry {
    let registry = HandlerRegistry::new();
    registry.register_simple("greet", |model: &mut dyn std::any::Any| {
        if let Some(m) = model.downcast_mut::<Model>() {
            m.message = "Hello World!".to_string();
        }
    });
    registry
}
```

### Application Logic (`src/main.rs`)

The main entry point orchestrates views and handlers:

```rust
struct DampenApp {
    current_view: CurrentView,
    window_state: AppState<ui::window::Model>,
}

fn update(app: &mut DampenApp, message: HandlerMessage) -> Task<HandlerMessage> {
    match message {
        HandlerMessage::Handler(handler_name, value) => {
            dispatch_handler(app, &handler_name, value);
        }
    }
    Task::none()
}

fn view(app: &DampenApp) -> Element<'_, HandlerMessage> {
    DampenWidgetBuilder::from_app_state(&app.window_state).build()
}
```

## Features Demonstrated

- âœ… **Auto-Loading UI**: XML files loaded automatically via `#[dampen_ui]` macro
- âœ… **Data Binding**: UI automatically updates when model changes
- âœ… **Event Handlers**: Connect UI events to Rust functions
- âœ… **Type Safety**: Full Rust type checking on your state
- âœ… **Declarative**: Separate UI structure from logic

## Next Steps

### Modify the UI

Edit `src/ui/window.dampen` to add more widgets:

```xml
<row spacing="10">
    <button label="Button 1" on_click="handler1" />
    <button label="Button 2" on_click="handler2" />
</row>
```

### Add State

Update your `Model` in `src/ui/window.rs`:

```rust
#[derive(Default, UiModel, Serialize, Deserialize, Clone, Debug)]
pub struct Model {
    pub message: String,
    pub counter: i32,
    pub enabled: bool,  // Add new fields
}
```

### Add Handlers

Create new event handlers in `src/ui/window.rs`:

```rust
registry.register_simple("reset", |model: &mut dyn std::any::Any| {
    if let Some(m) = model.downcast_mut::<Model>() {
        m.counter = 0;
        m.message = "Reset!".to_string();
    }
});
```

Then connect them in the UI:

```xml
<button label="Reset" on_click="reset" />
```

### Add New Views

Create additional views by adding new modules in `src/ui/`:

1. Create `src/ui/settings.rs` with its own `Model` and `#[dampen_ui("settings.dampen")]`
2. Create `src/ui/settings.dampen` XML file
3. Update `src/ui/mod.rs` to export the new module
4. Update `CurrentView` enum in `src/main.rs`

## Available Widgets

- `<dampen>` - Root element wrapping the entire UI
- `<column>` - Vertical layout (attributes: `padding`, `spacing`)
- `<row>` - Horizontal layout (attributes: `spacing`)
- `<text>` - Display text (attributes: `value`, `size`, `weight`)
- `<button>` - Clickable button (attributes: `label`, events: `on_click`)
- `<radio>` - Radio button (attributes: `label`, `value`, `selected`, `disabled`)

## Building for Production

Create an optimized release build:

```bash
cargo build --release
```

Your binary will be in `target/release/{{PROJECT_NAME}}`.

## Running Tests

Run the integration tests:

```bash
cargo test
```

## Documentation

- [Dampen Documentation](https://docs.rs/dampen-core)
- [Iced Documentation](https://docs.rs/iced)
- [XML Schema Reference](../../specs/001-framework-technical-specs/contracts/xml-schema.md)

## Troubleshooting

**Compilation errors:**
- Ensure all handlers are registered in `create_handler_registry()`
- Check that handler names in XML match function names
- Verify your model derives `UiModel`, `Serialize`, and `Deserialize`

**Bindings don't work:**
- Field names in `{field}` must match your `Model` struct exactly
- Make sure your model derives `UiModel`
- Check the console for binding evaluation errors

**Macro errors:**
- Ensure the XML file path in `#[dampen_ui("...")]` is correct (relative to the .rs file)
- XML file must be in the same directory as the .rs file or use proper relative path

---

Happy coding with Dampen! ðŸš€
