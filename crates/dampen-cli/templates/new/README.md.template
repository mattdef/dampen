# {{PROJECT_NAME}}

A Dampen UI application - build declarative UIs with XML and Rust!

## Quick Start

Run the application in development mode (with hot-reload):

```bash
dampen run
```

Build for production (with codegen):

```bash
dampen build --release
# or equivalently:
dampen release
```

This will open a window with your UI. Click the button to see bindings in action!

## Project Structure

```
{{PROJECT_NAME}}/
â”œâ”€â”€ Cargo.toml              # Project dependencies
â”œâ”€â”€ README.md               # This file
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs             # Application entry point
â”‚   â””â”€â”€ ui/
â”‚       â”œâ”€â”€ mod.rs          # UI module
â”‚       â”œâ”€â”€ window.rs       # UI model and handlers
â”‚       â””â”€â”€ window.dampen   # Declarative UI definition (XML)
â””â”€â”€ tests/
    â””â”€â”€ integration.rs      # Integration tests
```

## Understanding the Code

### UI Definition (`src/ui/window.dampen`)

The UI is defined declaratively in XML:

```xml
<dampen version="1.0">
    <column padding="40" spacing="20">
        <text value="Hello, Dampen!" size="32" weight="bold" />
        <button label="Click me!" on_click="greet" />
        <text value="{message}" size="24" />
    </column>
</dampen>
```

- **Root element**: `<dampen version="1.0">` wraps the entire UI
- **Bindings**: `{message}` automatically displays the `message` field from your model
- **Handlers**: `on_click="greet"` connects the button to the `greet` function
- **Layout**: Use `<column>` and `<row>` to arrange widgets

### UI Module (`src/ui/window.rs`)

The UI module defines your model and handlers using the auto-loading pattern:

```rust
#[derive(Default, UiModel, Serialize, Deserialize, Clone, Debug)]
pub struct Model {
    pub message: String,
}

#[dampen_ui("window.dampen")]
mod _app {}

pub fn create_app_state() -> AppState<Model> {
    let document = _app::document();
    let handler_registry = create_handler_registry();
    AppState::with_handlers(document, handler_registry)
}

pub fn create_handler_registry() -> HandlerRegistry {
    let registry = HandlerRegistry::new();
    registry.register_simple("greet", |model: &mut dyn std::any::Any| {
        if let Some(m) = model.downcast_mut::<Model>() {
            m.message = "Hello World!".to_string();
        }
    });
    registry
}
```

### Application Logic (`src/main.rs`)

The main entry point uses the `#[dampen_app]` macro for automatic setup:

```rust
#[dampen_app(
    ui_dir = "src/ui",
    message_type = "Message",
    handler_variant = "Handler",
    hot_reload_variant = "HotReload",
    dismiss_error_variant = "DismissError"
)]
struct DampenApp;

pub fn main() -> iced::Result {
    iced::application(DampenApp::init, DampenApp::update, DampenApp::view)
        .window_size(iced::Size::new(400.0, 300.0))
        .centered()
        .title("{{PROJECT_NAME}}")
        .subscription(DampenApp::subscription)
        .run()
}
```

The macro automatically generates:
- View discovery and loading from `src/ui/` directory
- Handler dispatch routing
- Hot-reload support with error overlay
- Type-safe view management

## Features Demonstrated

- âœ… **Auto-Loading UI**: XML files loaded automatically via `#[dampen_ui]` macro
- âœ… **Auto-Generated Views**: The `#[dampen_app]` macro discovers and manages all views
- âœ… **Data Binding**: UI automatically updates when model changes
- âœ… **Event Handlers**: Connect UI events to Rust functions
- âœ… **Hot-Reload**: Changes to `.dampen` files update instantly in development
- âœ… **Type Safety**: Full Rust type checking on your state
- âœ… **Multi-View Ready**: Easy to add more views - just create new files
- âœ… **Declarative**: Separate UI structure from logic

## Next Steps

### Modify the UI

Edit `src/ui/window.dampen` to add more widgets:

```xml
<row spacing="10">
    <button label="Button 1" on_click="handler1" />
    <button label="Button 2" on_click="handler2" />
</row>
```

### Add State

Update your `Model` in `src/ui/window.rs`:

```rust
#[derive(Default, UiModel, Serialize, Deserialize, Clone, Debug)]
pub struct Model {
    pub message: String,
    pub counter: i32,
    pub enabled: bool,  // Add new fields
}
```

### Add Handlers

Create new event handlers in `src/ui/window.rs`:

```rust
registry.register_simple("reset", |model: &mut dyn std::any::Any| {
    if let Some(m) = model.downcast_mut::<Model>() {
        m.counter = 0;
        m.message = "Reset!".to_string();
    }
});
```

Then connect them in the UI:

```xml
<button label="Reset" on_click="reset" />
```

### Add New Views

The `#[dampen_app]` macro makes multi-view apps easy! Just create new files:

1. **Create `src/ui/settings.rs`:**
```rust
use dampen_core::{AppState, HandlerRegistry};
use dampen_macros::{UiModel, dampen_ui};
use serde::{Deserialize, Serialize};

#[dampen_ui("settings.dampen")]
mod _app {}

#[derive(Default, UiModel, Serialize, Deserialize, Clone, Debug)]
pub struct Model {
    pub theme: String,
}

pub fn create_app_state() -> AppState<Model> {
    let document = _app::document();
    let handler_registry = HandlerRegistry::new();
    AppState::with_handlers(document, handler_registry)
}
```

2. **Create `src/ui/settings.dampen`:**
```xml
<dampen version="1.0">
    <column padding="20">
        <text value="Settings" size="24" />
        <button label="Back" on_click="back_to_main" />
    </column>
</dampen>
```

3. **Export in `src/ui/mod.rs`:**
```rust
pub mod window;
pub mod settings;  // Add this line
```

4. **Enable view switching in `src/main.rs`:**
```rust
// Uncomment these lines in main.rs:
enum Message {
    SwitchToView(CurrentView),  // Uncomment
    Handler(HandlerMessage),
    // ...
}

#[dampen_app(
    ui_dir = "src/ui",
    message_type = "Message",
    handler_variant = "Handler",
    switch_view_variant = "SwitchToView",  // Uncomment
    default_view = "window",  // Uncomment
    // ...
)]
```

5. **Add navigation handlers in `src/ui/window.rs`:**
```rust
use crate::{CurrentView, Message};

registry.register_with_command("switch_to_settings", |_model: &mut dyn std::any::Any| {
    Box::new(iced::Task::done(Message::SwitchToView(CurrentView::Settings)))
});
```

That's it! The macro automatically discovers the new view and generates all the plumbing.

## Available Widgets

- `<dampen version="1.0">` - Root element wrapping the entire UI
- `<column>` - Vertical layout (attributes: `padding`, `spacing`)
- `<row>` - Horizontal layout (attributes: `spacing`)
- `<text>` - Display text (attributes: `value`, `size`, `weight`)
- `<button>` - Clickable button (attributes: `label`, events: `on_click`)
- `<radio>` - Radio button (attributes: `label`, `value`, `selected`, `disabled`)

## CLI Commands

Dampen provides a comprehensive CLI for all development tasks:

```bash
# Development
dampen run                    # Run in dev mode with hot-reload (interpreted)
dampen build                  # Debug build (interpreted)
dampen run -- --arg         # Pass arguments to your application

# Production
dampen run --release          # Run in release mode (codegen)
dampen build --release        # Release build (codegen)
dampen release                # Alias for build --release

# Validation & Inspection
dampen check                  # Validate .dampen XML files
dampen inspect <file>         # Inspect IR and generated code

# Testing
dampen test                   # Run all tests
dampen test <name>            # Run specific test
```

### Mode Selection

- **Interpreted (default)**: Fast development with hot-reload
- **Codegen (--release)**: Production builds with zero runtime overhead

## Building for Production

Create an optimized release build with codegen:

```bash
dampen build --release
# or equivalently:
dampen release
```

Your binary will be in `target/release/{{PROJECT_NAME}}`.

> **Note**: Codegen mode requires a `build.rs` file in your project (automatically
> included when creating projects with `dampen new`).

## Running Tests

Run the integration tests:

```bash
dampen test
```

## Documentation

- [Dampen Documentation](https://docs.rs/dampen-core)
- [Iced Documentation](https://docs.rs/iced)
- [XML Schema Reference](../../specs/001-framework-technical-specs/contracts/xml-schema.md)

**Note**: You only need `cargo` to install the Dampen CLI initially:
```bash
cargo install dampen-cli
```
After that, use `dampen` commands for all development tasks.

## Troubleshooting

**Compilation errors:**
- Ensure all handlers are registered in `create_handler_registry()`
- Check that handler names in XML match function names
- Verify your model derives `UiModel`, `Serialize`, and `Deserialize`

**Bindings don't work:**
- Field names in `{field}` must match your `Model` struct exactly
- Make sure your model derives `UiModel`
- Check the console for binding evaluation errors

**Macro errors:**
- Ensure the XML file path in `#[dampen_ui("...")]` is correct (relative to the .rs file)
- XML file must be in the same directory as the .rs file or use proper relative path

---

Happy coding with Dampen! ðŸš€
