//! Build script for Dampen projects
//!
//! This build script scans the ui/ directory for .dampen files and generates
//! Rust code from them for production builds.

use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    // Get the ui directory
    let ui_dir = PathBuf::from("ui");

    // Only proceed if ui directory exists
    if !ui_dir.exists() {
        println!("cargo:warning=ui/ directory not found, skipping code generation");
        return;
    }

    // Get output directory
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    // Scan for .dampen files
    let dampen_files = find_dampen_files(&ui_dir);

    if dampen_files.is_empty() {
        println!("cargo:warning=No .dampen files found in ui/ directory");
        return;
    }

    // Generate code
    let generated_code = generate_from_files(&dampen_files);

    // Write to output file
    let output_file = out_dir.join("ui_generated.rs");
    fs::write(&output_file, generated_code).expect("Failed to write generated code");

    // Include the generated file
    println!("cargo:rustc-env=DAMPEN_GENERATED={}", output_file.display());

    // Tell cargo to rerun if any .dampen files change
    for file in &dampen_files {
        println!("cargo:rerun-if-changed={}", file.display());
    }

    // Also rerun if this build script changes
    println!("cargo:rerun-if-changed=build.rs");
}

/// Find all .dampen files in a directory recursively
fn find_dampen_files(dir: &Path) -> Vec<PathBuf> {
    let mut files = Vec::new();

    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.filter_map(|e| e.ok()) {
            let path = entry.path();

            if path.is_dir() {
                files.extend(find_dampen_files(&path));
            } else if path.extension().map_or(false, |ext| ext == "dampen") {
                files.push(path);
            }
        }
    }

    files
}

/// Generate Rust code from multiple .dampen files
fn generate_from_files(files: &[PathBuf]) -> String {
    let mut code = String::new();

    // Add header
    code.push_str("//! Auto-generated UI code\n");
    code.push_str("//! DO NOT EDIT - This file is generated by build.rs\n\n");
    code.push_str("use dampen_core::parse;\n");
    code.push_str("use dampen_core::codegen::generate_application;\n");
    code.push_str("use dampen_core::HandlerSignature;\n\n");

    // Generate for each file
    for file in files {
        let content = fs::read_to_string(file).unwrap_or_else(|_| String::new());
        let file_name = file.file_stem().unwrap().to_string_lossy();
        let var_name = file_name.replace("-", "_");

        // Parse the file
        match dampen_core::parse(&content) {
            Ok(doc) => {
                // For now, generate a placeholder
                // In a full implementation, this would use actual handler signatures
                code.push_str(&format!("pub fn generate_{}() -> String {{\n", var_name));
                code.push_str(&format!(
                    "    let xml = r#\"{}\"#;\n",
                    content.replace('"', "\\\"")
                ));
                code.push_str("    let doc = parse(xml).unwrap();\n");
                code.push_str("    let handlers: Vec<HandlerSignature> = vec![];\n");
                code.push_str(&format!(
                    "    let output = generate_application(&doc, \"{}Model\", \"{}Message\", &handlers).unwrap();\n",
                    file_name, file_name
                ));
                code.push_str("    output.code\n");
                code.push_str("}\n\n");
            }
            Err(e) => {
                println!("cargo:warning=Failed to parse {}: {}", file.display(), e);
            }
        }
    }

    code
}
