// Auto-generated by `dampen new`
// This build script generates static Rust code from .dampen UI files in codegen mode

use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
    // Only generate code in codegen mode
    // In interpreted mode, XML is loaded at runtime via #[dampen_ui] macro
    #[cfg(feature = "codegen")]
    {
        generate_ui_code();
    }

    #[cfg(not(feature = "codegen"))]
    {
        // Interpreted mode - no code generation needed
        // The #[dampen_ui] macro handles runtime XML loading
        println!("cargo:rerun-if-changed=src/ui/");
    }
}

#[cfg(feature = "codegen")]
fn generate_ui_code() {
    // Get output directory for generated code
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let out_path = PathBuf::from(&out_dir);

    // Find all .dampen files in src/ui/
    let ui_dir = PathBuf::from("src/ui");
    if !ui_dir.exists() {
        eprintln!("Warning: src/ui/ directory not found, skipping code generation");
        return;
    }

    let dampen_files = find_dampen_files(&ui_dir);

    if dampen_files.is_empty() {
        eprintln!("Warning: No .dampen files found in src/ui/");
        return;
    }

    println!("cargo:rerun-if-changed=src/ui/");

    // Generate code for all .dampen files
    let mut generated = String::new();
    generated.push_str("// Auto-generated - DO NOT EDIT\n");
    generated.push_str("// Regenerate with: cargo build --features codegen\n\n");

    for file in &dampen_files {
        println!("cargo:rerun-if-changed={}", file.display());

        // Parse XML and generate code using dampen-core
        // This is a placeholder - full implementation will use dampen-core parser and codegen
        let module_name = file
            .file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("unknown");

        generated.push_str(&format!(
            "// Generated from: {}\n\
             pub mod {} {{\n\
             \tuse dampen_core::DampenDocument;\n\
             \tuse std::sync::LazyLock;\n\
             \n\
             \tpub static DOCUMENT: LazyLock<DampenDocument> = LazyLock::new(|| {{\n\
             \t\t// TODO: Generate actual widget code here\n\
             \t\tpanic!(\"Codegen not yet fully implemented for {}\")\n\
             \t}});\n\
             \n\
             \tpub fn document() -> DampenDocument {{\n\
             \t\t(*DOCUMENT).clone()\n\
             \t}}\n\
             }}\n\n",
            file.display(),
            module_name,
            module_name
        ));
    }

    // Write generated code
    let output_file = out_path.join("ui_generated.rs");
    fs::write(&output_file, &generated).expect("Failed to write generated code");

    // Expose path to generated code
    println!("cargo:rustc-env=DAMPEN_GENERATED={}", output_file.display());

    println!("Generated UI code from {} files", dampen_files.len());
}

#[cfg(feature = "codegen")]
fn find_dampen_files(dir: &PathBuf) -> Vec<PathBuf> {
    let mut files = Vec::new();

    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                files.extend(find_dampen_files(&path));
            } else if path.extension().and_then(|s| s.to_str()) == Some("dampen") {
                files.push(path);
            }
        }
    }

    files
}
