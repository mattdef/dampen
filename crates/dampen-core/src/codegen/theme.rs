//! Theme code generation for production builds
//!
//! This module generates static Rust code from theme definitions.
//! The generated code allows themes to be compiled directly into the binary
//! with zero runtime parsing overhead.

use super::GeneratedCode;
use crate::ir::style::Color;
use crate::ir::theme::ThemeDocument;

/// Generate Rust code for a theme document
///
/// This function generates a Rust module containing functions to access
/// themes at runtime without any parsing overhead.
///
/// # Arguments
///
/// * `document` - The parsed theme document
/// * `module_name` - Name for the generated module (e.g., "app" â†’ app_theme module)
///
/// # Returns
///
/// Ok(GeneratedCode) with the generated Rust code, or an error if validation fails
///
/// # Example Output
///
/// ```rust,ignore
/// // Generated theme code
/// pub fn app_theme() -> iced::Theme {
///     app_default_theme()
/// }
///
/// pub fn app_themes() -> HashMap<&'static str, iced::Theme> {
///     let mut themes = HashMap::new();
///     themes.insert("light", app_theme_light());
///     themes.insert("dark", app_theme_dark());
///     themes
/// }
///
/// fn app_theme_light() -> iced::Theme {
///     iced::Theme::custom(
///         "light".to_string(),
///         iced::theme::Palette {
///             background: iced::Color::from_rgb8(0xEC, 0xF0, 0xF1),
///             text: iced::Color::from_rgb8(0x2C, 0x3E, 0x50),
///             primary: iced::Color::from_rgb8(0x34, 0x98, 0xDB),
///             success: iced::Color::from_rgb8(0x27, 0xAE, 0x60),
///             warning: iced::Color::from_rgb8(0xF3, 0x9C, 0x12),
///             danger: iced::Color::from_rgb8(0xE7, 0x4C, 0x3C),
///         }
///     )
/// }
/// ```
pub fn generate_theme_code(
    document: &ThemeDocument,
    module_name: &str,
) -> Result<GeneratedCode, String> {
    if document.themes.is_empty() {
        return Err("THEME_001: At least one theme must be defined".to_string());
    }

    let mut code = String::new();

    code.push_str("//! Generated theme code - DO NOT EDIT\n");
    code.push_str("//! This file is auto-generated by the dampen codegen.\n\n");

    code.push_str("use std::collections::HashMap;\n");
    code.push_str("use iced::Color;\n");
    code.push_str("use iced::Theme;\n\n");

    code.push_str("/// Get the theme by name, or the default if not found\n");
    code.push_str(&format!("pub fn {}_theme() -> Theme {{\n", module_name));
    code.push_str(&format!("    {}_default_theme()\n", module_name));
    code.push_str("}\n\n");

    code.push_str("/// Get a specific theme by name\n");
    code.push_str(&format!(
        "pub fn {}_theme_named(name: &str) -> Option<Theme> {{\n",
        module_name
    ));
    code.push_str(&format!("    let themes = {}_themes();\n", module_name));
    code.push_str("    themes.get(name).cloned()\n");
    code.push_str("}\n\n");

    code.push_str("/// Get all available themes\n");
    code.push_str(&format!(
        "pub fn {}_themes() -> HashMap<&'static str, Theme> {{\n",
        module_name
    ));
    code.push_str("    let mut themes = HashMap::new();\n");

    let mut theme_names: Vec<&str> = document.themes.keys().map(|s| s.as_str()).collect();
    theme_names.sort();

    for theme_name in &theme_names {
        code.push_str(&format!(
            "    themes.insert(\"{}\", {}_{}());\n",
            theme_name, module_name, theme_name
        ));
    }

    code.push_str("    themes\n");
    code.push_str("}\n\n");

    code.push_str("/// Get the default theme\n");
    code.push_str(&format!(
        "pub fn {}_default_theme() -> Theme {{\n",
        module_name
    ));

    let effective_default = document.effective_default(None);
    code.push_str(&format!("    {}_{}()\n", module_name, effective_default));
    code.push_str("}\n\n");

    code.push_str("/// Get the default theme name as a string\n");
    code.push_str(&format!(
        "pub fn {}_default_theme_name() -> &'static str {{\n",
        module_name
    ));
    code.push_str(&format!("    \"{}\"\n", effective_default));
    code.push_str("}\n\n");

    code.push_str("/// Get whether the theme follows system preference\n");
    code.push_str(&format!(
        "pub fn {}_follows_system() -> bool {{\n",
        module_name
    ));
    code.push_str(&format!("    {}\n", document.follow_system));
    code.push_str("}\n\n");

    for theme_name in &theme_names {
        let theme = match document.themes.get(*theme_name) {
            Some(t) => t,
            None => continue,
        };

        let theme_fn_name = format!("{}_{}", module_name, theme_name);
        code.push_str(&format!("/// Theme: {}\n", theme_name));
        code.push_str("fn ");
        code.push_str(&theme_fn_name);
        code.push_str("() -> Theme {\n");

        let palette = &theme.palette;
        let primary = color_to_rgb8_tuple(palette.primary.as_ref());
        let background = color_to_rgb8_tuple(palette.background.as_ref());
        let text = color_to_rgb8_tuple(palette.text.as_ref());
        let success = color_to_rgb8_tuple(palette.success.as_ref());
        let warning = color_to_rgb8_tuple(palette.warning.as_ref());
        let danger = color_to_rgb8_tuple(palette.danger.as_ref());

        code.push_str("    Theme::custom(\n");
        code.push_str(&format!("        \"{}\".to_string(),\n", theme_name));
        code.push_str("        iced::theme::Palette {\n");
        code.push_str(&format!(
            "            background: iced::Color::from_rgb8(0x{:02X}, 0x{:02X}, 0x{:02X}),\n",
            (background.0 * 255.0) as u8,
            (background.1 * 255.0) as u8,
            (background.2 * 255.0) as u8
        ));
        code.push_str(&format!(
            "            text: iced::Color::from_rgb8(0x{:02X}, 0x{:02X}, 0x{:02X}),\n",
            (text.0 * 255.0) as u8,
            (text.1 * 255.0) as u8,
            (text.2 * 255.0) as u8
        ));
        code.push_str(&format!(
            "            primary: iced::Color::from_rgb8(0x{:02X}, 0x{:02X}, 0x{:02X}),\n",
            (primary.0 * 255.0) as u8,
            (primary.1 * 255.0) as u8,
            (primary.2 * 255.0) as u8
        ));
        code.push_str(&format!(
            "            success: iced::Color::from_rgb8(0x{:02X}, 0x{:02X}, 0x{:02X}),\n",
            (success.0 * 255.0) as u8,
            (success.1 * 255.0) as u8,
            (success.2 * 255.0) as u8
        ));
        code.push_str(&format!(
            "            warning: iced::Color::from_rgb8(0x{:02X}, 0x{:02X}, 0x{:02X}),\n",
            (warning.0 * 255.0) as u8,
            (warning.1 * 255.0) as u8,
            (warning.2 * 255.0) as u8
        ));
        code.push_str(&format!(
            "            danger: iced::Color::from_rgb8(0x{:02X}, 0x{:02X}, 0x{:02X}),\n",
            (danger.0 * 255.0) as u8,
            (danger.1 * 255.0) as u8,
            (danger.2 * 255.0) as u8
        ));
        code.push_str("        }\n");
        code.push_str("    )\n");
        code.push_str("}\n\n");
    }

    let source_file = format!("{}/theme.dampen", module_name);
    Ok(GeneratedCode::new(
        code,
        format!("{}_theme", module_name),
        std::path::PathBuf::from(source_file),
    ))
}

/// Convert a color to RGB tuple (0.0-1.0 range)
fn color_to_rgb8_tuple(color: Option<&Color>) -> (f32, f32, f32) {
    match color {
        Some(c) => (c.r, c.g, c.b),
        None => (0.0, 0.0, 0.0),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::style::Color;
    use crate::ir::theme::{SpacingScale, Theme, ThemePalette, Typography};

    fn create_test_palette_with_hex(hex: &str) -> ThemePalette {
        ThemePalette {
            primary: Some(Color::from_hex(hex).unwrap()),
            secondary: Some(Color::from_hex("#2ecc71").unwrap()),
            success: Some(Color::from_hex("#27ae60").unwrap()),
            warning: Some(Color::from_hex("#f39c12").unwrap()),
            danger: Some(Color::from_hex("#e74c3c").unwrap()),
            background: Some(Color::from_hex("#ecf0f1").unwrap()),
            surface: Some(Color::from_hex("#ffffff").unwrap()),
            text: Some(Color::from_hex("#2c3e50").unwrap()),
            text_secondary: Some(Color::from_hex("#7f8c8d").unwrap()),
        }
    }

    fn create_test_theme(name: &str, primary_hex: &str) -> Theme {
        Theme {
            name: name.to_string(),
            palette: create_test_palette_with_hex(primary_hex),
            typography: Typography {
                font_family: Some("sans-serif".to_string()),
                font_size_base: Some(16.0),
                font_size_small: Some(12.0),
                font_size_large: Some(24.0),
                font_weight: crate::ir::theme::FontWeight::Normal,
                line_height: Some(1.5),
            },
            spacing: SpacingScale { unit: Some(8.0) },
            base_styles: std::collections::HashMap::new(),
            extends: None,
        }
    }

    #[test]
    fn test_generate_theme_code_basic() {
        let doc = ThemeDocument {
            themes: std::collections::HashMap::from([(
                "light".to_string(),
                create_test_theme("light", "#3498db"),
            )]),
            default_theme: Some("light".to_string()),
            follow_system: false,
        };

        let result = generate_theme_code(&doc, "test");

        assert!(result.is_ok());
        let code = result.unwrap().code;

        assert!(code.contains("pub fn test_theme()"));
        assert!(code.contains("pub fn test_themes()"));
        assert!(code.contains("pub fn test_default_theme()"));
        assert!(code.contains("fn test_light()"));
        assert!(code.contains("Theme::custom"));
        assert!(code.contains("Color::from_rgb8"));
    }

    #[test]
    fn test_generate_theme_code_multiple_themes() {
        let doc = ThemeDocument {
            themes: std::collections::HashMap::from([
                ("light".to_string(), create_test_theme("light", "#3498db")),
                ("dark".to_string(), create_test_theme("dark", "#5dade2")),
            ]),
            default_theme: Some("light".to_string()),
            follow_system: true,
        };

        let result = generate_theme_code(&doc, "app");

        assert!(result.is_ok());
        let code = result.unwrap().code;

        assert!(code.contains("fn app_light()"));
        assert!(code.contains("fn app_dark()"));
        assert!(code.contains("themes.insert(\"light\""));
        assert!(code.contains("themes.insert(\"dark\""));
    }

    #[test]
    fn test_generate_theme_code_empty_themes_error() {
        let doc = ThemeDocument {
            themes: std::collections::HashMap::new(),
            default_theme: None,
            follow_system: true,
        };

        let result = generate_theme_code(&doc, "app");

        assert!(result.is_err());
        let err = result.unwrap_err();
        assert!(err.contains("THEME_001") || err.contains("no themes"));
    }

    #[test]
    fn test_generate_theme_code_valid_rust_syntax() {
        let doc = ThemeDocument {
            themes: std::collections::HashMap::from([(
                "test".to_string(),
                create_test_theme("test", "#ff0000"),
            )]),
            default_theme: Some("test".to_string()),
            follow_system: false,
        };

        let result = generate_theme_code(&doc, "test");

        assert!(result.is_ok());
        let code = result.unwrap().code;

        let parsed = syn::parse_file(&code);
        assert!(
            parsed.is_ok(),
            "Generated code should be valid Rust syntax: {:?}",
            parsed.err()
        );
    }

    #[test]
    fn test_generate_theme_code_contains_color_values() {
        let doc = ThemeDocument {
            themes: std::collections::HashMap::from([(
                "custom".to_string(),
                create_test_theme("custom", "#AABBCC"),
            )]),
            default_theme: Some("custom".to_string()),
            follow_system: false,
        };

        let result = generate_theme_code(&doc, "myapp");

        assert!(result.is_ok());
        let code = result.unwrap().code;

        assert!(
            code.contains("0xAA") || code.contains("0xBB") || code.contains("0xCC"),
            "Generated code should contain the color values"
        );
    }
}
