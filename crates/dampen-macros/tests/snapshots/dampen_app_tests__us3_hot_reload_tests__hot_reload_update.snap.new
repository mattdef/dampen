---
source: crates/dampen-macros/tests/dampen_app_tests.rs
assertion_line: 375
expression: output_str
---
# [derive (Debug , Clone , PartialEq , Eq)] pub enum CurrentView { About , Home , Settings } pub struct App { about_state : dampen_core :: AppState < ui :: about :: Model > , home_state : dampen_core :: AppState < ui :: home :: Model > , settings_state : dampen_core :: AppState < ui :: settings :: Model > , current_view : CurrentView , } impl App { pub fn init () -> Self { Self { about_state : { let document = ui :: about :: _about :: document () ; # [allow (unused_mut)] let mut handlers = dampen_core :: HandlerRegistry :: new () ; dampen_core :: AppState :: with_handlers (document , handlers) } , home_state : { let document = ui :: home :: _home :: document () ; # [allow (unused_mut)] let mut handlers = dampen_core :: HandlerRegistry :: new () ; dampen_core :: AppState :: with_handlers (document , handlers) } , settings_state : { let document = ui :: settings :: _settings :: document () ; # [allow (unused_mut)] let mut handlers = dampen_core :: HandlerRegistry :: new () ; dampen_core :: AppState :: with_handlers (document , handlers) } , current_view : CurrentView :: About , } } pub fn new () -> Self { Self :: init () } pub fn switch_to_about (& mut self) { self . current_view = CurrentView :: About ; } pub fn switch_to_home (& mut self) { self . current_view = CurrentView :: Home ; } pub fn switch_to_settings (& mut self) { self . current_view = CurrentView :: Settings ; } pub fn update (& mut self , message : Message) -> iced :: Task < Message > { match message { Message :: Handler (_handler_msg) => { match self . current_view { CurrentView :: About => { } CurrentView :: Home => { } CurrentView :: Settings => { } } iced :: Task :: none () } # [cfg (debug_assertions)] Message :: HotReload (event) => { match event { dampen_dev :: subscription :: FileEvent :: Success { path , document } => { if let Some (path_str) = path . to_str () { if path_str . ends_with ("about.dampen") { # [cfg (debug_assertions)] if let Some (ref mut overlay) = self . error_overlay { overlay . hide () ; } return iced :: Task :: none () ; } if path_str . ends_with ("home.dampen") { # [cfg (debug_assertions)] if let Some (ref mut overlay) = self . error_overlay { overlay . hide () ; } return iced :: Task :: none () ; } if path_str . ends_with ("settings.dampen") { # [cfg (debug_assertions)] if let Some (ref mut overlay) = self . error_overlay { overlay . hide () ; } return iced :: Task :: none () ; } } iced :: Task :: none () } dampen_dev :: subscription :: FileEvent :: ParseError { path , error , content : _ } => { if let Some (ref mut overlay) = self . error_overlay { overlay . show (error) ; } iced :: Task :: none () } dampen_dev :: subscription :: FileEvent :: WatcherError { path : _ , error : _ } => { iced :: Task :: none () } } } _ => iced :: Task :: none () , } } pub fn view (& self) -> iced :: Element < '_ , Message > { match self . current_view { CurrentView :: About => { iced :: widget :: text ("View rendering not yet implemented") . into () } CurrentView :: Home => { iced :: widget :: text ("View rendering not yet implemented") . into () } CurrentView :: Settings => { iced :: widget :: text ("View rendering not yet implemented") . into () } } } # [cfg (debug_assertions)] pub fn subscription (& self) -> iced :: Subscription < Message > { dampen_dev :: subscription :: watch_files (vec ! [std :: path :: PathBuf :: from ("/home/matt/Documents/Dev/dampen/crates/dampen-macros/tests/fixtures/multi_view/src/ui/about.dampen") , std :: path :: PathBuf :: from ("/home/matt/Documents/Dev/dampen/crates/dampen-macros/tests/fixtures/multi_view/src/ui/home.dampen") , std :: path :: PathBuf :: from ("/home/matt/Documents/Dev/dampen/crates/dampen-macros/tests/fixtures/multi_view/src/ui/settings.dampen")] , 100) . map (Message :: HotReload) } }
