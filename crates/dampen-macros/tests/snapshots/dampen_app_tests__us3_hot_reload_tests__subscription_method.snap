---
source: crates/dampen-macros/tests/dampen_app_tests.rs
assertion_line: 341
expression: output_str
---
# [derive (Debug , Clone , PartialEq , Eq)] pub enum CurrentView { About , Home , Settings } pub struct App { about_state : dampen_core :: AppState < ui :: about :: Model > , home_state : dampen_core :: AppState < ui :: home :: Model > , settings_state : dampen_core :: AppState < ui :: settings :: Model > , current_view : CurrentView , # [cfg (debug_assertions)] error_overlay : dampen_dev :: ErrorOverlay } impl App { pub fn init () -> Self { Self { about_state : ui :: about :: create_app_state () , home_state : ui :: home :: create_app_state () , settings_state : ui :: settings :: create_app_state () , current_view : CurrentView :: About , # [cfg (debug_assertions)] error_overlay : dampen_dev :: ErrorOverlay :: new () , } } pub fn new () -> Self { Self :: init () } pub fn switch_to_about (& mut self) { self . current_view = CurrentView :: About ; } pub fn switch_to_home (& mut self) { self . current_view = CurrentView :: Home ; } pub fn switch_to_settings (& mut self) { self . current_view = CurrentView :: Settings ; } pub fn update (& mut self , message : Message) -> iced :: Task < Message > { fn dispatch_handler_with_task < M : dampen_core :: UiBindable + 'static > (model : & mut M , registry : & dampen_core :: HandlerRegistry , handler_msg : dampen_iced :: HandlerMessage ,) -> iced :: Task < Message > { match handler_msg { dampen_iced :: HandlerMessage :: Handler (handler_name , value) => { let model_any : & mut dyn std :: any :: Any = model ; if let Some (boxed_task) = registry . dispatch_with_command (& handler_name , model_any , value) { if let Ok (task) = boxed_task . downcast :: < iced :: Task < Message >> () { return * task ; } } iced :: Task :: none () } } } match message { Message :: Handler (handler_msg) => { match self . current_view { CurrentView :: About => { dispatch_handler_with_task (& mut self . about_state . model , & self . about_state . handler_registry , handler_msg) } CurrentView :: Home => { dispatch_handler_with_task (& mut self . home_state . model , & self . home_state . handler_registry , handler_msg) } CurrentView :: Settings => { dispatch_handler_with_task (& mut self . settings_state . model , & self . settings_state . handler_registry , handler_msg) } } } # [cfg (debug_assertions)] Message :: HotReload (event) => { match event { dampen_dev :: subscription :: FileEvent :: Success { path , document } => { if let Some (path_str) = path . to_str () { if path_str . ends_with ("about.dampen") { self . about_state . hot_reload (* document . clone ()) ; # [cfg (debug_assertions)] { self . error_overlay . hide () ; } return iced :: Task :: none () ; } if path_str . ends_with ("home.dampen") { self . home_state . hot_reload (* document . clone ()) ; # [cfg (debug_assertions)] { self . error_overlay . hide () ; } return iced :: Task :: none () ; } if path_str . ends_with ("settings.dampen") { self . settings_state . hot_reload (* document . clone ()) ; # [cfg (debug_assertions)] { self . error_overlay . hide () ; } return iced :: Task :: none () ; } } iced :: Task :: none () } dampen_dev :: subscription :: FileEvent :: ParseError { path , error , content : _ } => { # [cfg (debug_assertions)] { self . error_overlay . show (error) ; } iced :: Task :: none () } dampen_dev :: subscription :: FileEvent :: WatcherError { path : _ , error : _ } => { iced :: Task :: none () } } } # [cfg (debug_assertions)] Message :: DismissError => { self . error_overlay . hide () ; iced :: Task :: none () } _ => iced :: Task :: none () , } } pub fn view (& self) -> iced :: Element < '_ , Message > { # [cfg (debug_assertions)] if self . error_overlay . is_visible () { return self . error_overlay . render (Message :: DismissError) ; } match self . current_view { CurrentView :: About => { dampen_iced :: DampenWidgetBuilder :: from_app_state (& self . about_state) . build () . map (Message :: Handler) } CurrentView :: Home => { dampen_iced :: DampenWidgetBuilder :: from_app_state (& self . home_state) . build () . map (Message :: Handler) } CurrentView :: Settings => { dampen_iced :: DampenWidgetBuilder :: from_app_state (& self . settings_state) . build () . map (Message :: Handler) } } } # [cfg (debug_assertions)] pub fn subscription (& self) -> iced :: Subscription < Message > { dampen_dev :: subscription :: watch_files (vec ! [std :: path :: PathBuf :: from ("/home/matt/Documents/Dev/dampen/crates/dampen-macros/tests/fixtures/multi_view/src/ui/about.dampen") , std :: path :: PathBuf :: from ("/home/matt/Documents/Dev/dampen/crates/dampen-macros/tests/fixtures/multi_view/src/ui/home.dampen") , std :: path :: PathBuf :: from ("/home/matt/Documents/Dev/dampen/crates/dampen-macros/tests/fixtures/multi_view/src/ui/settings.dampen")] , 100) . map (Message :: HotReload) } # [cfg (not (debug_assertions))] pub fn subscription (& self) -> iced :: Subscription < Message > { iced :: Subscription :: none () } }
