// Auto-generated by Dampen codegen build script
// This build script generates static Rust code from .dampen UI files for production builds

extern crate dampen_core;
extern crate toml;

use std::env;
use std::fs;
use std::path::{Path, PathBuf};

use quote::quote;
use syn::{Attribute, FnArg, ItemFn, ReturnType};
use walkdir::WalkDir;

fn main() {
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let out_path = PathBuf::from(&out_dir);

    // Find all .dampen files in src/ui/
    let ui_dir = PathBuf::from("src/ui");
    if !ui_dir.exists() {
        println!("cargo:warning=src/ui/ directory not found, skipping codegen");
        return;
    }

    let dampen_files = find_dampen_files(&ui_dir);

    if dampen_files.is_empty() {
        println!("cargo:warning=No .dampen files found in src/ui/");
        return;
    }

    // Emit rerun-if-changed for all UI files
    for file in &dampen_files {
        println!("cargo:rerun-if-changed={}", file.display());
    }
    println!("cargo:rerun-if-changed=src/ui/");
    println!("cargo:rerun-if-changed=src/"); // Watch all source files for handler changes
    println!("cargo:rerun-if-changed=Cargo.toml");

    // Generate code for each .dampen file
    for file in &dampen_files {
        generate_code_for_file(file, &out_path);
    }

    println!("cargo:rustc-env=DAMPEN_CODEGEN_ENABLED=1");
    println!("Generated UI code from {} files", dampen_files.len());
}

/// Generate Rust code from a .dampen file
fn generate_code_for_file(input_file: &Path, out_dir: &Path) {
    let file_stem = input_file.file_stem().expect("Invalid file name");
    let module_name = format!("ui_{}", file_stem.to_string_lossy().replace('-', "_"));
    let output_file = out_dir.join(format!("{}.rs", module_name));

    // Read the XML content
    let xml_content = match fs::read_to_string(input_file) {
        Ok(content) => content,
        Err(e) => {
            eprintln!("Error reading {}: {}", input_file.display(), e);
            return;
        }
    };

    // Parse the XML and generate code using dampen-core
    let generated_code = match generate_ui_code(&xml_content, &module_name) {
        Ok(code) => code,
        Err(e) => {
            eprintln!("Error generating code for {}: {}", input_file.display(), e);
            generate_error_placeholder(&module_name, &e)
        }
    };

    // Write the generated code
    if let Err(e) = fs::write(&output_file, &generated_code) {
        eprintln!("Error writing {}: {}", output_file.display(), e);
        return;
    }
    println!("Generated: {}", output_file.display());
}

/// Generate UI code from XML content
fn generate_ui_code(xml_content: &str, module_name: &str) -> Result<String, String> {
    // Use dampen-core to parse and generate code
    let parsed = dampen_core::parse(xml_content).map_err(|e| format!("Parse error: {:?}", e))?;

    // Auto-discover handlers from #[ui_handler] annotations
    let handlers = discover_handlers().or_else(|_| {
        // Fallback to handlers.toml if discovery fails (for backward compatibility)
        println!("cargo:warning=Handler auto-discovery failed, falling back to handlers.toml");
        load_handlers_manifest()
    })?;

    let output = dampen_core::codegen::generate_application(&parsed, "Model", "Message", &handlers)
        .map_err(|e| format!("Codegen error: {:?}", e))?;

    Ok(format!(
        "// Auto-generated by Dampen codegen - DO NOT EDIT\n\
         // Source: {}.dampen\n\n\
         {}\n",
        module_name.replace("ui_", ""),
        output.code
    ))
}

/// Load handlers from handlers.toml manifest
fn load_handlers_manifest() -> Result<Vec<dampen_core::HandlerSignature>, String> {
    let content = match fs::read_to_string("handlers.toml") {
        Ok(c) => c,
        Err(_) => return Ok(Vec::new()),
    };

    let value: toml::Value = content
        .parse::<toml::Value>()
        .map_err(|e| format!("TOML parse error: {:?}", e))?;
    let table = value.as_table().ok_or("Invalid TOML format".to_string())?;

    let mut handlers = Vec::new();

    for (name, table_value) in table.iter() {
        let param_type = table_value
            .get("params")
            .and_then(|p: &toml::Value| p.as_array())
            .and_then(|p: &Vec<toml::Value>| {
                if p.is_empty() {
                    None
                } else {
                    p[0].as_str().map(|s: &str| s.to_string())
                }
            });

        let returns_command = table_value
            .get("command")
            .and_then(|c: &toml::Value| c.as_bool())
            .unwrap_or(false);

        handlers.push(dampen_core::HandlerSignature {
            name: name.clone(),
            param_type,
            returns_command,
        });
    }

    Ok(handlers)
}

/// Generate error placeholder when code generation fails
fn generate_error_placeholder(module_name: &str, error: &str) -> String {
    format!(
        "// ERROR: Code generation failed for {}\n\
         // {}\n\
         // Please fix the .dampen file and rebuild.\n\n\
         compile_error!(\"Dampen codegen failed: {}\");\n",
        module_name, error, error
    )
}

/// Recursively find all .dampen files in a directory
fn find_dampen_files(dir: &Path) -> Vec<PathBuf> {
    let mut files = Vec::new();

    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                files.extend(find_dampen_files(&path));
            } else if path.extension().and_then(|s| s.to_str()) == Some("dampen") {
                files.push(path);
            }
        }
    }

    files
}

/// Auto-discover handlers annotated with #[ui_handler]
fn discover_handlers() -> Result<Vec<dampen_core::HandlerSignature>, String> {
    let src_dir = PathBuf::from("src");
    let rust_files = find_rust_files(&src_dir)?;

    let mut handlers = Vec::new();
    for file in rust_files {
        let file_handlers = parse_file_for_handlers(&file)?;
        handlers.extend(file_handlers);
    }

    Ok(handlers)
}

/// Find all .rs files in directory recursively
fn find_rust_files(dir: &Path) -> Result<Vec<PathBuf>, String> {
    let mut files = Vec::new();
    for entry in WalkDir::new(dir)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().and_then(|s| s.to_str()) == Some("rs"))
    {
        files.push(entry.path().to_path_buf());
    }
    Ok(files)
}

/// Parse a Rust file to find handlers with #[ui_handler] attribute
fn parse_file_for_handlers(path: &Path) -> Result<Vec<dampen_core::HandlerSignature>, String> {
    let content = fs::read_to_string(path)
        .map_err(|e| format!("Failed to read {}: {}", path.display(), e))?;

    let ast = syn::parse_file(&content)
        .map_err(|e| format!("Failed to parse {}: {}", path.display(), e))?;

    let mut visitor = HandlerVisitor {
        handlers: Vec::new(),
    };

    use syn::visit::Visit;
    visitor.visit_file(&ast);
    Ok(visitor.handlers)
}

/// Visitor pattern to find functions with #[ui_handler] attribute
struct HandlerVisitor {
    handlers: Vec<dampen_core::HandlerSignature>,
}

impl<'ast> syn::visit::Visit<'ast> for HandlerVisitor {
    fn visit_item_fn(&mut self, node: &'ast ItemFn) {
        // Check if function has #[ui_handler] attribute
        if has_ui_handler_attr(&node.attrs) {
            if let Some(signature) = extract_handler_signature(node) {
                self.handlers.push(signature);
            }
        }
        syn::visit::visit_item_fn(self, node);
    }
}

/// Check if attributes contain #[ui_handler]
fn has_ui_handler_attr(attrs: &[Attribute]) -> bool {
    attrs.iter().any(|attr| {
        attr.path()
            .segments
            .last()
            .map(|seg| seg.ident == "ui_handler")
            .unwrap_or(false)
    })
}

/// Extract handler signature from function
fn extract_handler_signature(func: &ItemFn) -> Option<dampen_core::HandlerSignature> {
    let name = func.sig.ident.to_string();

    // Analyze parameters (skip first one which is &mut Model)
    let param_type = func.sig.inputs.iter().nth(1).and_then(|param| {
        if let FnArg::Typed(pat_type) = param {
            let ty = &pat_type.ty;
            Some(quote!(#ty).to_string())
        } else {
            None
        }
    });

    // Check if returns Command
    let returns_command = if let ReturnType::Type(_, ty) = &func.sig.output {
        let return_str = quote!(#ty).to_string();
        return_str.contains("Command") || return_str.contains("Task")
    } else {
        false
    };

    Some(dampen_core::HandlerSignature {
        name,
        param_type,
        returns_command,
    })
}
