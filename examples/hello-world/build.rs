// Auto-generated by Dampen
// This build script generates static Rust code from .dampen UI files in codegen mode

#[cfg(feature = "codegen")]
use std::env;
#[cfg(feature = "codegen")]
use std::fs;
#[cfg(feature = "codegen")]
use std::path::PathBuf;

fn main() {
    // Only generate code in codegen mode
    // In interpreted mode, XML is loaded at runtime via #[dampen_ui] macro
    #[cfg(feature = "codegen")]
    {
        generate_ui_code();
    }

    #[cfg(not(feature = "codegen"))]
    {
        // Interpreted mode - no code generation needed
        // The #[dampen_ui] macro handles runtime XML loading
        println!("cargo:rerun-if-changed=src/ui/");
    }
}

#[cfg(feature = "codegen")]
fn generate_ui_code() {
    use dampen_core::codegen::{CodegenError, generate_application_with_theme_and_subscriptions};
    use dampen_core::parser::theme_parser::parse_theme_document;
    use dampen_core::{HandlerSignature, parser};

    // Get output directory for generated code
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let out_path = PathBuf::from(&out_dir);

    // Find all .dampen files in src/ui/
    let ui_dir = PathBuf::from("src/ui");
    if !ui_dir.exists() {
        eprintln!("Warning: src/ui/ directory not found, skipping code generation");
        return;
    }

    println!("cargo:rerun-if-changed=src/ui/");

    // Parse theme file if it exists
    let theme_path = ui_dir.join("theme/theme.dampen");
    let theme_document = if theme_path.exists() {
        println!("cargo:rerun-if-changed={}", theme_path.display());
        match fs::read_to_string(&theme_path) {
            Ok(content) => match parse_theme_document(&content) {
                Ok(doc) => Some(doc),
                Err(e) => {
                    eprintln!("Warning: Failed to parse theme file: {}", e);
                    None
                }
            },
            Err(e) => {
                eprintln!("Warning: Failed to read theme file: {}", e);
                None
            }
        }
    } else {
        None
    };

    // Parse the main window.dampen file
    let window_path = ui_dir.join("window.dampen");
    if !window_path.exists() {
        eprintln!("Warning: src/ui/window.dampen not found");
        return;
    }

    println!("cargo:rerun-if-changed={}", window_path.display());

    let window_content = match fs::read_to_string(&window_path) {
        Ok(c) => c,
        Err(e) => {
            eprintln!("Error: Failed to read window.dampen: {}", e);
            return;
        }
    };

    let document = match parser::parse(&window_content) {
        Ok(doc) => doc,
        Err(e) => {
            eprintln!("Error: Failed to parse window.dampen: {}", e);
            return;
        }
    };

    // Define handlers (these match what's registered in window.rs)
    let handlers = vec![HandlerSignature {
        name: "greet".to_string(),
        param_type: None,
        returns_command: false,
    }];

    // Generate the application code with theme and subscription support
    let output = match generate_application_with_theme_and_subscriptions(
        &document,
        "Model",
        "Message",
        &handlers,
        theme_document.as_ref(),
    ) {
        Ok(output) => output,
        Err(e) => {
            eprintln!("Error: Code generation failed: {}", e);
            return;
        }
    };

    // Write generated code
    let output_file = out_path.join("ui_generated.rs");
    if let Err(e) = fs::write(&output_file, &output.code) {
        eprintln!("Error: Failed to write generated code: {}", e);
        return;
    }

    // Print any warnings
    for warning in &output.warnings {
        println!("cargo:warning={}", warning);
    }

    // Expose path to generated code
    println!("cargo:rustc-env=DAMPEN_GENERATED={}", output_file.display());

    println!("Generated UI code successfully");
}
