# Research: Production Mode with Static Code Generation

**Feature**: 008-prod-codegen | **Date**: 2026-01-08

## Decision 1: Handler Metadata Extraction

**Question**: How to extract handler metadata from proc macros for build.rs consumption?

### Options Evaluated

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| A. Static array in macro | Emit `static HANDLER_REGISTRY: &[HandlerInfo]` | Direct access, no parsing | Increases binary size, harder to modify |
| B. JSON file emission | Write metadata to JSON during macro expansion | Easy parsing, separate format | File I/O overhead, needs cleanup |
| C. Rust module emission | Generate `handlers_metadata.rs` with static data | Clean separation, type-safe | Requires proper module inclusion |
| D. Symbol extraction | Use compiler internals to find handlers | No macro changes needed | Fragile, version-dependent |

### Decision: Option C - Rust Module Emission

**Rationale**: Maintains type safety, integrates cleanly with existing code generation pipeline, and follows Rust conventions for code generation. The generated module can be `include!`d or imported normally.

**Implementation**:
```rust
// Generated by #[ui_handler] macro
pub mod handler_metadata {
    pub static HANDLERS: &[super::HandlerInfo] = &[
        HandlerInfo {
            name: "on_click",
            signature_type: HandlerSignatureType::Simple,
            param_types: &["&mut Model"],
            return_type: "()",
        },
        // ... more handlers
    ];
}
```

### Alternatives Considered

- Option A rejected: Binary bloat and less flexibility for future changes
- Option B rejected: JSON parsing adds complexity without benefit
- Option D rejected: Compiler internals are unstable and not portable

---

## Decision 2: build.rs Code Generation Pattern

**Question**: How to structure code generation in Cargo build scripts?

### Options Evaluated

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| A. Single file generation | Generate one ui_generated.rs per project | Simple, easy to include | Can become large for complex apps |
| B. Per-view generation | Generate separate files per .gravity file | Modular, incremental builds | More complex include pattern |
| C. Hybrid approach | Generate single file with module per view | Best of both | Slightly more complex template |

### Decision: Option A - Single File Generation

**Rationale**: Simpler implementation, matches existing patterns in the codebase, and acceptable file size for typical applications. Can be optimized to per-view generation in future if needed.

**Implementation**:
```rust
// build.rs
fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let gravity_files = find_gravity_files("src/ui");
    
    let mut generated = String::new();
    generated.push_str("// Auto-generated - DO NOT EDIT\n\n");
    generated.push_str("use gravity_core::codegen::generate_application;\n");
    generated.push_str("use gravity_core::{parse, HandlerRegistry};\n\n");
    
    for file in &gravity_files {
        let doc = parse(&fs::read_to_string(file)?)?;
        let output = generate_application(&doc, "Model", "Message", &handlers)?;
        generated.push_str(&output.code);
    }
    
    let out_file = PathBuf::from(out_dir).join("ui_generated.rs");
    fs::write(&out_file, &generated)?;
    
    println!("cargo:rustc-env=GRAVITY_GENERATED={}", out_file.display());
}
```

### Alternatives Considered

- Option B rejected: Added complexity without immediate benefit for current scope
- Option C rejected: Can be evolved to this pattern if single file becomes problematic

---

## Decision 3: Circular Dependency Detection

**Question**: How to detect handler call cycles at compile time?

### Options Evaluated

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| A. Static analysis | Analyze handler call graph at build time | Early detection, no runtime cost | Complex implementation |
| B. Runtime guard | Track handler calls with visited set | Simple, detects at runtime | Performance overhead, late detection |
| C. Hybrid detection | Simple static check + runtime guard | Balanced approach | Both systems needed |
| D. Manual annotation | Developer marks non-cyclic handlers | Simplest to implement | Error-prone, burden on developers |

### Decision: Option A - Static Analysis with Option B Fallback

**Rationale**: Static analysis aligns with the feature goal of compile-time guarantees. For complex cases, a configurable runtime guard can be enabled via feature flag.

**Implementation**:
```rust
// Build-time analysis
fn analyze_handler_dependencies(handlers: &[HandlerInfo]) -> Result<(), BuildError> {
    let mut graph = HashMap::new();
    
    // Build call graph from handler signatures and XML references
    for handler in handlers {
        let calls = extract_handler_calls(handler, &xml_doc);
        graph.insert(handler.name.clone(), calls);
    }
    
    // Detect cycles using DFS
    let mut visited = HashSet::new();
    let mut recursion_stack = HashSet::new();
    
    for handler in handlers {
        if detect_cycle(handler, &graph, &mut visited, &mut recursion_stack) {
            return Err(BuildError::CircularDependency(handler.clone()));
        }
    }
    
    Ok(())
}
```

### Alternatives Considered

- Option B rejected: Runtime overhead contradicts performance goals
- Option D rejected: Manual process is error-prone and doesn't scale

---

## Decision 4: Generated Code Structure

**Question**: How should the generated Rust code be structured?

### Decision: Iced Widget Builder Pattern

**Rationale**: Follows existing `GravityWidgetBuilder` pattern in `gravity-iced`, maintaining consistency with the development mode API.

**Generated Code Structure**:
```rust
// ui_generated.rs
use gravity_iced::{GravityWidgetBuilder, HandlerMessage};

pub fn generate_app() -> impl iced::Widget<Model, Message> {
    GravityWidgetBuilder::new()
        .text("Hello")
        .button("Click", Some(Message::OnClick))
        .build()
}

#[derive(Clone, Debug)]
pub enum Message {
    OnClick,
}
```

---

## Decision 5: Error Message Format

**Question**: What format should error messages follow?

### Decision: Structured Error Format

**Rationale**: Consistent with Rust ecosystem conventions, actionable for developers.

**Error Message Format**:
```
Error: Handler 'on_submit' referenced in app.gravity:15 not found
  --> app.gravity:15
   |
15 | <button handler="on_submit">Submit</button>
   |                    ^^^^^^^^
   
Did you mean: on_submit_form (defined in src/handlers.rs:42)
```

---

## Summary

| Decision | Choice | Key Benefit |
|----------|--------|-------------|
| Metadata extraction | Rust module emission | Type-safe, clean integration |
| Code generation | Single file generation | Simplicity and maintainability |
| Circular deps | Static analysis + optional guard | Compile-time guarantees |
| Code structure | Iced Widget Builder pattern | API consistency |
| Error format | Structured messages | Developer experience |

## References

- [Rust proc macro best practices](https://doc.rust-lang.org/reference/procedural-macros.html)
- [Cargo build.rs documentation](https://doc.rust-lang.org/cargo/reference/build-scripts.html)
- [Circular dependency detection algorithms](https://en.wikipedia.org/wiki/Cycle_detection)
