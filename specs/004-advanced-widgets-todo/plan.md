# Implementation Plan: Advanced Widgets for Modern Todo App

**Branch**: `004-advanced-widgets-todo` | **Date**: 2026-01-04 | **Spec**: [spec.md](./spec.md)

## Summary

Add 8 advanced Iced widgets to Gravity (ComboBox, PickList, Canvas, ProgressBar, Tooltip, Grid, Float, Image-verified) to enable building modern, feature-rich applications. Implement comprehensive todo-app example demonstrating all widgets with professional styling and full CRUD functionality. Extend Gravity runtime with widget state management for stateful widgets like ComboBox.

**Technical Approach** (from research):
- Add 6 new variants to `WidgetKind` enum (Image already exists)
- Extend XML parser for new widget-specific attributes
- Implement rendering logic in `GravityWidgetBuilder`
- Add widget state management to gravity-runtime
- Hybrid declarative/imperative approach for Canvas
- Build fully functional modern todo app showcasing all features

---

## Technical Context

**Language/Version**: Rust Edition 2024, MSRV 1.75  
**Primary Dependencies**: Iced 0.14+ (already in workspace)  
**Storage**: JSON state files via serde_json (existing pattern)  
**Testing**: cargo test, integration tests, visual testing  
**Target Platform**: Linux, Windows, macOS (tier 1 support)  
**Project Type**: Workspace with 5 crates  
**Performance Goals**: < 50ms for 50-100 widget todo app, < 500ms hot-reload latency  
**Constraints**: Must maintain backward compatibility, no breaking changes to existing widgets  
**Scale/Scope**: 8 new widgets, 1 comprehensive example app, ~3000 lines new code across crates  

---

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### I. Declarative-First ✅ **PASS**

- ComboBox, PickList, ProgressBar, Tooltip, Grid, Float: Fully declarative XML
- Canvas: Hybrid approach (XML declares placement, Rust implements rendering)
  - **Justification**: Canvas inherently requires imperative drawing logic
  - **Mitigation**: Clearly documented hybrid pattern, consider future declarative DSL
- All widgets parseable without runtime context
- IR representation captures complete semantics

**Gate Decision**: PASS with documented exception for Canvas

### II. Type Safety Preservation ✅ **PASS**

- All widget attributes are type-checked at parse time
- Event handlers have verified signatures (via `#[ui_handler]` macro)
- Bindings evaluated with type constraints
- ComboBox/PickList values are strongly typed strings
- Canvas Program trait preserves type safety for custom rendering
- No `Any`-based dispatch except for internal widget state management (encapsulated)

**Gate Decision**: PASS

### III. Dual-Mode Architecture ✅ **PASS**

**Development Mode**:
- All 8 widgets supported in hot-reload
- Widget state persists across reloads (ComboBox::State)
- Parse errors shown in overlay
- Hot-reload latency < 500ms maintained

**Production Mode**:
- Code generation via GravityWidgetBuilder (existing pattern)
- No XML parsing at runtime
- Full compile-time verification
- Generated code remains human-readable

**Gate Decision**: PASS

### IV. Backend Abstraction ✅ **PASS**

- Widget types added to backend-agnostic gravity-core IR
- All widget-specific Iced code in gravity-iced crate
- gravity-core has no Iced dependencies
- New widgets follow existing abstraction pattern
- Future backends can implement same IR widget types

**Gate Decision**: PASS

### V. Test-First Development ✅ **COMMITTED**

**Testing Plan**:
- Contract tests for XML parsing all 8 widgets
- Integration tests for GravityWidgetBuilder rendering
- Property-based tests for ComboBox search filtering
- Hot-reload behavior tests for widget state persistence
- Visual regression tests for todo-app example
- Snapshot tests for generated code (if applicable)

**Gate Decision**: PASS - tests will be written before implementation

---

**Post-Design Re-Check**: All gates PASS after Phase 1 design

---

## Project Structure

### Documentation (this feature)

```text
specs/004-advanced-widgets-todo/
├── spec.md              # Feature specification (COMPLETE)
├── plan.md              # This file (IN PROGRESS)
├── research.md          # Widget API research (COMPLETE)
├── data-model.md        # IR and app data models (COMPLETE)
├── quickstart.md        # Developer guide (COMPLETE)
├── contracts/           
│   └── xml-schema.md    # XML contracts for all widgets (COMPLETE)
├── checklists/
│   └── requirements.md  # Spec validation checklist (COMPLETE)
└── tasks.md             # Task breakdown (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
crates/
├── gravity-core/         # Core IR and parser (CHANGES REQUIRED)
│   ├── src/
│   │   ├── ir/
│   │   │   ├── node.rs          # ADD: 6 new WidgetKind variants
│   │   │   └── ...
│   │   ├── parser/
│   │   │   ├── mod.rs           # MODIFY: Parse new widget elements
│   │   │   ├── attributes.rs    # ADD: New attribute parsing logic
│   │   │   └── ...
│   │   └── ...
│   └── tests/
│       └── widget_parsing_tests.rs  # ADD: Test new widget parsing
│
├── gravity-runtime/      # Hot-reload runtime (CHANGES REQUIRED)
│   ├── src/
│   │   ├── state.rs             # MODIFY: Add widget state management
│   │   ├── interpreter.rs       # VERIFY: Hot-reload works with new widgets
│   │   └── ...
│   └── tests/
│       └── state_management_tests.rs  # ADD: Test widget state persistence
│
├── gravity-iced/         # Iced backend (CHANGES REQUIRED)
│   ├── src/
│   │   ├── builder.rs           # MODIFY: Add rendering for 8 widgets
│   │   ├── convert.rs           # ADD: Type conversions for new attributes
│   │   └── ...
│   └── tests/
│       └── widget_rendering_tests.rs  # ADD: Test widget rendering
│
├── gravity-cli/          # Developer CLI (VERIFY)
│   ├── src/
│   │   ├── commands/
│   │   │   ├── check.rs         # VERIFY: Validates new widgets
│   │   │   └── dev.rs           # VERIFY: Hot-reload works
│   │   └── ...
│   └── tests/
│       └── cli_tests.rs
│
└── gravity-macros/       # Proc macros (NO CHANGES)
    └── ...

examples/
├── todo-app/             # Complete modern todo app (MAJOR REWRITE)
│   ├── src/
│   │   └── main.rs              # REWRITE: Full todo app with all widgets
│   ├── ui/
│   │   └── main.gravity         # REWRITE: Modern UI using all 8 widgets
│   ├── assets/                  # ADD: Priority icons, images
│   │   ├── priority-low.png
│   │   ├── priority-medium.png
│   │   └── priority-high.png
│   └── Cargo.toml
│
└── widget-showcase/      # NEW: Individual widget examples
    ├── src/
    │   └── main.rs
    ├── ui/
    │   ├── combobox.gravity
    │   ├── picklist.gravity
    │   ├── canvas.gravity
    │   ├── progressbar.gravity
    │   ├── tooltip.gravity
    │   ├── grid.gravity
    │   └── float.gravity
    └── Cargo.toml
```

**Structure Decision**: 
Using existing workspace structure. No new crates required. All widget implementations go into existing gravity-core and gravity-iced crates following established patterns. New comprehensive todo-app example replaces minimal existing one.

---

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| Canvas requires Rust code | Custom graphics inherently imperative | Pure XML drawing DSL would be limiting and complex |

**Rationale**: Canvas is the only widget requiring Rust code for rendering logic via `canvas::Program` trait. This is unavoidable for flexible custom graphics. We mitigate by keeping XML declarative for placement and size, only requiring Rust for drawing operations. Future enhancement could add simple declarative shape DSL for common visualizations.

---

## Phase 0: Research ✅ COMPLETE

**Output**: `research.md`

### Key Findings

1. **All 8 widgets available in Iced 0.14+**
   - ComboBox, PickList, Canvas, ProgressBar, Tooltip, Grid, Float, Image all confirmed
   - No new dependencies required
   - May need to enable `canvas` and `image` feature flags

2. **State Management Required**
   - ComboBox needs `combo_box::State<T>` for search functionality
   - Solution: Extend gravity-runtime with `HashMap<String, Box<dyn Any>>` for widget states
   - State keyed by widget `id` attribute (auto-generated if missing)

3. **Canvas Hybrid Approach**
   - Cannot be fully declarative (requires custom drawing code)
   - Users implement `canvas::Program<Message>` trait in Rust
   - XML declares canvas size and placement
   - Documented pattern with examples

4. **Float Widget Verification**
   - Float exists in Iced but API needs testing
   - May pivot to `pin` widget if Float doesn't meet needs
   - Defer final decision to implementation phase

5. **Performance Budget**
   - Estimated ~15ms base rendering for todo app
   - Canvas adds variable cost (depends on drawing complexity)
   - Well within < 50ms target for 50-100 widgets

### Research Decisions

- ✅ Use existing `EventKind::Select` for dropdown events
- ✅ Parse comma-separated options as `Vec<String>`
- ✅ Implement widget state management in gravity-runtime
- ✅ Use `#[ui_skip]` attribute for Canvas Program fields
- ✅ Auto-clamp ProgressBar values to [min, max] range
- ✅ Tooltip default delay 2000ms (customizable)

---

## Phase 1: Design & Contracts ✅ COMPLETE

**Output**: `data-model.md`, `contracts/xml-schema.md`, `quickstart.md`

### Data Model

**IR Extensions**:
```rust
// gravity-core/src/ir/node.rs
pub enum WidgetKind {
    // ... existing ...
    ComboBox,      // NEW
    ProgressBar,   // NEW
    Tooltip,       // NEW
    Grid,          // NEW
    Canvas,        // NEW
    Float,         // NEW (or Pin)
}
```

**Runtime State**:
```rust
// gravity-runtime/src/state.rs
pub struct GravityRuntimeState {
    pub user_model: Box<dyn UiBindable>,
    pub widget_states: HashMap<String, Box<dyn Any>>,  // NEW
}
```

**Todo App Model**:
```rust
#[derive(UiModel)]
struct TodoAppModel {
    items: Vec<TodoItem>,
    current_filter: TodoFilter,
    new_item_text: String,
    selected_category: String,
    selected_priority: Priority,
    completion_percentage: f32,
    #[ui_skip]
    statistics_chart: StatisticsChart,
}

struct TodoItem {
    id: String,
    text: String,
    category: String,
    priority: Priority,
    completed: bool,
    created_at: String,
    due_date: Option<String>,
}
```

### XML Schema Contracts

**ComboBox**:
```xml
<combobox 
    options="Work,Personal,Shopping"
    selected="{category}"
    placeholder="Select..."
    on_select="handler"
/>
```

**PickList**: Same structure as ComboBox (different widget internally)

**Canvas**:
```xml
<canvas width="400" height="200" program="{chart}" />
```

**ProgressBar**:
```xml
<progress_bar min="0" max="100" value="{percent}" style="success" />
```

**Tooltip**:
```xml
<tooltip message="Help text" position="top">
    <button label="Action" />
</tooltip>
```

**Grid**:
```xml
<grid columns="5" spacing="10">
    <!-- Children flow left-to-right, wrapping rows -->
</grid>
```

**Float**:
```xml
<float position="bottom_right" offset_x="-20" offset_y="-20" z_index="100">
    <button label="+" />
</float>
```

### Validation Rules

- ComboBox/PickList: `options` required, min 1, max 100 items
- Canvas: `width` and `height` required, min 50px, max 4000px
- ProgressBar: value auto-clamped to [min, max]
- Tooltip: must wrap exactly 1 child
- Grid: `columns` required, min 1, max 20
- Float: position enum validated at parse time

---

## Phase 2: Implementation Plan

### Overview

Implementation broken into 6 stages across 4 crates, with todo-app example as final integration test.

### Stage 1: Core IR Extensions (gravity-core)

**Crate**: `gravity-core`

**Files to Modify**:
1. `src/ir/node.rs` - Add WidgetKind variants
2. `src/parser/mod.rs` - Parse new widget elements
3. `src/parser/attributes.rs` - New attribute parsing logic
4. `tests/widget_parsing_tests.rs` - Contract tests

**Tasks**:
1. Add 6 new `WidgetKind` variants (ComboBox, ProgressBar, Tooltip, Grid, Canvas, Float)
2. Implement XML element name to WidgetKind mapping
3. Add attribute structures for each widget (see data-model.md)
4. Implement attribute parsing with validation:
   - Comma-separated list parsing for `options`
   - Enum parsing for `position`, `style`
   - Number parsing with range validation
   - Required vs optional attribute handling
5. Write contract tests for each widget:
   - Valid XML parses successfully
   - Missing required attributes error
   - Invalid attribute values error
   - Child count validation (Tooltip=1, Grid=0+, others=0)

**Acceptance Criteria**:
- All 8 widget types parse from XML to WidgetNode IR
- All attributes validate correctly
- Contract tests pass for valid and invalid inputs
- No breaking changes to existing widget parsing

**Estimated Effort**: 2-3 days

---

### Stage 2: Runtime State Management (gravity-runtime)

**Crate**: `gravity-runtime`

**Files to Modify**:
1. `src/state.rs` - Add widget state management
2. `src/interpreter.rs` - Update for stateful widgets
3. `tests/state_management_tests.rs` - State persistence tests

**Tasks**:
1. Add `widget_states: HashMap<String, Box<dyn Any>>` to runtime state
2. Implement `get_or_create_state<T>()` method:
   ```rust
   pub fn get_or_create_state<T: Default + 'static>(&mut self, widget_id: &str) -> &mut T
   ```
3. Implement widget ID generation for widgets without explicit `id` attribute
4. Ensure state persists across hot-reloads (serialize/deserialize)
5. Add state cleanup when widgets removed from UI

**Acceptance Criteria**:
- ComboBox state (search text, dropdown state) persists across hot-reloads
- Canvas state (if any) accessible from rendering code
- Memory doesn't leak when widgets added/removed
- State tests verify persistence and cleanup

**Estimated Effort**: 1-2 days

---

### Stage 3: Widget Rendering (gravity-iced) - Part 1: Simple Widgets

**Crate**: `gravity-iced`

**Files to Modify**:
1. `src/builder.rs` - Add widget rendering logic
2. `src/convert.rs` - Type conversions for attributes
3. `tests/widget_rendering_tests.rs` - Rendering tests

**Tasks for Simple Widgets** (PickList, ProgressBar):
1. Implement `build_picklist()`:
   - Parse `options` into `Vec<String>`
   - Evaluate `selected` binding to get current value
   - Map `on_select` event to HandlerMessage
   - Build `iced::widget::pick_list()`
2. Implement `build_progressbar()`:
   - Parse `min`, `max`, `value` attributes
   - Evaluate `value` binding
   - Clamp value to range
   - Map `style` to Iced progress bar style
   - Build `iced::widget::progress_bar()`
3. Add type conversions in `convert.rs`:
   - `ProgressBarStyle` → Iced style function
   - String list → Vec<String>

**Acceptance Criteria**:
- PickList renders with options and selection
- ProgressBar renders with correct value and style
- Event handlers fire and update model
- Bindings evaluate correctly

**Estimated Effort**: 1 day

---

### Stage 4: Widget Rendering (gravity-iced) - Part 2: Container Widgets

**Crate**: `gravity-iced`

**Tasks for Container Widgets** (Tooltip, Grid, Float):
1. Implement `build_tooltip()`:
   - Parse `message`, `position`, `delay` attributes
   - Verify exactly 1 child widget
   - Recursively build child widget
   - Build `iced::widget::tooltip()`
   - Map position enum to Iced Position
2. Implement `build_grid()`:
   - Parse `columns`, `spacing`, `padding`
   - Recursively build all child widgets
   - Collect into iterator
   - Build `iced::widget::grid().columns(n).spacing(s)`
3. Implement `build_float()`:
   - **VERIFY Float API first** (may use `pin` instead)
   - Parse `position`, `offset_x`, `offset_y`, `z_index`
   - Recursively build child widget
   - Build `iced::widget::float()` (or `pin()`)
   - Handle visibility binding

**Acceptance Criteria**:
- Tooltip wraps child and shows on hover
- Grid lays out children in columns
- Float positions child correctly
- All position/style enums convert correctly

**Estimated Effort**: 2 days

---

### Stage 5: Widget Rendering (gravity-iced) - Part 3: Stateful Widgets

**Crate**: `gravity-iced`

**Tasks for Stateful Widgets** (ComboBox, Canvas):
1. Implement `build_combobox()`:
   - Get or create `combo_box::State<String>` from runtime state
   - Parse `options` into Vec<String>
   - Pre-populate state with options
   - Evaluate `selected` binding
   - Map `on_select` event to HandlerMessage with value
   - Build `iced::widget::combo_box(state, placeholder, selection, on_select)`
2. Implement `build_canvas()`:
   - Parse `width`, `height` attributes
   - Evaluate `program` binding to get `impl canvas::Program<Message>`
   - Build `iced::widget::canvas(program).width(w).height(h)`
   - Handle `on_click` event if present (pass coordinates)
3. Add state access to builder:
   ```rust
   impl GravityWidgetBuilder {
       fn get_widget_state<T: Default + 'static>(&self, id: &str) -> &mut T;
   }
   ```

**Acceptance Criteria**:
- ComboBox search filtering works
- ComboBox state persists across renders
- Canvas renders custom Program implementation
- Canvas click events fire with coordinates
- Widget state accessed without panic

**Estimated Effort**: 2-3 days

---

### Stage 6: Todo App Example

**Crate**: `examples/todo-app`

**Files to Create/Modify**:
1. `src/main.rs` - Complete rewrite with full todo app
2. `ui/main.gravity` - Modern UI using all 8 widgets
3. `assets/` - Priority icons (low, medium, high)
4. `README.md` - Feature documentation

**Tasks**:
1. Implement TodoAppModel with all fields (see data-model.md)
2. Implement all event handlers:
   - `add_item`, `toggle_item`, `delete_item`
   - `clear_all`, `clear_completed`
   - `update_category`, `update_priority`, `apply_filter`
   - `toggle_dark_mode`, `show_add_dialog`
3. Implement StatisticsChart Canvas Program:
   - Draw 7-day completion trend
   - Draw axes and labels
   - Handle hover to show values
4. Design modern UI layout in XML:
   - Header with title and dark mode toggle
   - Statistics section with ProgressBar and Canvas
   - Add task form with ComboBox and PickList
   - Task list with Grid layout
   - Tooltips on all action buttons
   - Floating "Add" button
   - Priority icons using Image widget
5. Add styling for professional appearance:
   - Consistent spacing and padding
   - Color scheme (light/dark mode support)
   - Hover states for interactive elements
6. Test all features:
   - CRUD operations on todos
   - Category filtering with PickList
   - Priority assignment with PickList/ComboBox
   - Progress tracking with ProgressBar
   - Statistics visualization with Canvas
   - Contextual help with Tooltips
   - Responsive layout with Grid
   - Floating action button with Float
7. Create assets:
   - Design priority icons (or use placeholders)
   - Export as PNG (low, medium, high)

**Acceptance Criteria**:
- App demonstrates all 8 widgets in cohesive design
- All CRUD operations work correctly
- UI is visually modern and professional
- Hot-reload works with all widgets
- State persists across reloads
- No crashes or errors during normal use
- Code is < 400 lines (excluding boilerplate)

**Estimated Effort**: 3-4 days

---

### Stage 7: Testing & Validation

**All Crates**

**Tasks**:
1. **Unit Tests**: Each widget rendering function
2. **Integration Tests**: Full GravityWidgetBuilder pipeline
3. **Property-Based Tests**: ComboBox search filtering
4. **Hot-Reload Tests**: Widget state persistence
5. **Contract Tests**: XML parsing for all widgets
6. **Visual Tests**: Render all widgets and verify appearance
7. **Performance Tests**: Rendering latency for 50-100 widgets
8. **Validation Tests**: `gravity check` with all widgets

**Acceptance Criteria**:
- All tests pass
- Coverage > 90% for new code
- No clippy warnings
- No performance regressions
- Hot-reload latency < 500ms

**Estimated Effort**: 2-3 days

---

### Stage 8: Documentation & Polish

**All Documentation**

**Tasks**:
1. Update AGENTS.md with new widget types
2. Add widget reference to docs/
3. Update examples/README.md
4. Add troubleshooting guide to quickstart.md
5. Create widget showcase example
6. Record demo video (optional)
7. Write blog post (optional)

**Acceptance Criteria**:
- All public APIs documented
- Quickstart guide complete and tested
- Examples run without errors
- Documentation reviewed for clarity

**Estimated Effort**: 1-2 days

---

## Testing Strategy

### Test Pyramid

```
           /\
          /  \    E2E Tests: Todo app end-to-end (1)
         /    \
        /------\  Integration Tests: GravityWidgetBuilder (10)
       /        \
      /----------\ Unit Tests: Parsing, rendering, state (50)
     /            \
    /--------------\ Property Tests: Search, layout (5)
```

### Test Types

**Contract Tests** (gravity-core):
```rust
#[test]
fn parse_combobox_with_all_attributes() {
    let xml = r#"<combobox options="A,B,C" selected="{choice}" on_select="handler" />"#;
    let doc = parse(xml).unwrap();
    assert_eq!(doc.root.kind, WidgetKind::ComboBox);
    // Verify attributes parsed correctly
}

#[test]
fn parse_combobox_missing_options_errors() {
    let xml = r#"<combobox />"#;
    let result = parse(xml);
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("required attribute"));
}
```

**Rendering Tests** (gravity-iced):
```rust
#[test]
fn build_picklist_with_binding() {
    let model = TestModel { filter: "Active".to_string() };
    let node = create_picklist_node();
    let element = builder.build_widget(&node, &model);
    // Verify widget builds without panic
}
```

**State Persistence Tests** (gravity-runtime):
```rust
#[test]
fn combobox_state_persists_across_reload() {
    let mut state = GravityRuntimeState::new(model);
    let combobox_state = state.get_or_create_state::<ComboBoxState>("combo1");
    combobox_state.search_text = "test".to_string();
    
    // Simulate reload
    let json = serde_json::to_string(&state.widget_states).unwrap();
    let restored: HashMap<String, Box<dyn Any>> = serde_json::from_str(&json).unwrap();
    
    // Verify state restored
}
```

**Property-Based Tests**:
```rust
proptest! {
    #[test]
    fn combobox_search_filters_correctly(search in "\\PC{0,10}", options in prop::collection::vec("\\PC{1,20}", 1..100)) {
        let filtered = filter_options(&search, &options);
        for option in &filtered {
            assert!(option.to_lowercase().contains(&search.to_lowercase()));
        }
    }
}
```

---

## Performance Budget

### Targets

| Metric | Target | How to Measure |
|--------|--------|----------------|
| Parse time (1000 widgets) | < 10ms | Benchmark in gravity-core |
| Build time (100 widgets) | < 5ms | Benchmark in gravity-iced |
| Hot-reload latency | < 500ms | Measure file save → UI update |
| Todo app render (50 widgets) | < 50ms | Frame time measurement |
| Canvas draw (simple chart) | < 10ms | Canvas::draw() timing |

### Optimization Strategies

1. **Canvas Caching**: Use `Cache` for static geometry
2. **Lazy Evaluation**: Only evaluate bindings when needed
3. **Widget State Pooling**: Reuse state objects
4. **Efficient Parsing**: Use nom for attribute parsing
5. **Minimal Allocations**: Reuse Vec/String where possible

---

## Deployment Plan

### Pre-Release Checklist

- [ ] All tests pass (unit, integration, property)
- [ ] No clippy warnings
- [ ] Code formatted with rustfmt
- [ ] Documentation complete
- [ ] Examples run without errors
- [ ] Hot-reload tested manually
- [ ] Performance benchmarks meet targets
- [ ] Breaking changes documented (none expected)

### Release Process

1. Merge feature branch to main
2. Update CHANGELOG.md
3. Bump version numbers (patch: 0.1.x → 0.1.y)
4. Tag release: `git tag v0.1.y`
5. Push to GitHub: triggers CI
6. Publish to crates.io (when ready)
7. Announce in community channels

---

## Risks & Mitigation

### Risk Register

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Float API doesn't match expectations | Medium | High | Test early, pivot to `pin` widget |
| ComboBox state management complex | High | Medium | Prototype first, use existing patterns |
| Canvas performance issues | Medium | Low | Use caching, profile early |
| Todo app scope creep | Low | Medium | Strict feature limit, time-box |
| Hot-reload breaks with stateful widgets | High | Low | Thorough testing, fallback to restart |
| Image widget needs verification | Low | Low | Audit early, fix if needed |

### Contingency Plans

**If Float widget unsuitable**:
- Use `pin` widget instead
- Or use `overlay` for modals
- Update contracts/xml-schema.md with actual API

**If ComboBox state too complex**:
- Start with PickList only (simpler)
- Add ComboBox in follow-up PR
- Document limitations clearly

**If performance budget missed**:
- Profile and optimize hot paths
- Reduce todo app widget count if needed
- Add performance tips to quickstart.md

---

## Timeline Estimate

### Development Schedule

| Stage | Duration | Dependencies |
|-------|----------|--------------|
| 1. Core IR | 2-3 days | None |
| 2. Runtime State | 1-2 days | Stage 1 |
| 3. Simple Widgets | 1 day | Stage 1, 2 |
| 4. Container Widgets | 2 days | Stage 1, 2 |
| 5. Stateful Widgets | 2-3 days | Stage 1, 2 |
| 6. Todo App | 3-4 days | All above |
| 7. Testing | 2-3 days | Stage 6 |
| 8. Documentation | 1-2 days | All above |

**Total**: 14-20 working days (3-4 weeks)

**Critical Path**: Stage 1 → Stage 2 → Stage 5 → Stage 6 → Stage 7

---

## Success Criteria (from Spec)

### Functional

- ✅ All 8 widgets render correctly in Iced
- ✅ All widget attributes parse and validate
- ✅ Event handlers connect and fire
- ✅ Data bindings update on model changes
- ✅ Widget state persists across hot-reloads
- ✅ Todo app demonstrates all widgets
- ✅ `gravity check` validates new widgets
- ✅ `gravity dev` hot-reloads new widgets

### Performance

- ✅ Hot-reload latency < 500ms
- ✅ Todo app renders in < 50ms (50-100 widgets)
- ✅ Compile time increase < 15% for gravity-iced
- ✅ No memory leaks in widget state management

### Quality

- ✅ All tests pass
- ✅ No clippy warnings
- ✅ Code coverage > 90% for new code
- ✅ Documentation complete and accurate
- ✅ Examples run without errors
- ✅ No breaking changes to existing features

---

## Next Steps

After `/speckit.plan` completion:

1. Run `/speckit.tasks` to generate detailed task breakdown
2. Begin Stage 1 implementation (Core IR Extensions)
3. Create feature branch: `004-advanced-widgets-todo`
4. Implement in phases, testing continuously
5. Review todo app UX with stakeholders
6. Merge when all success criteria met

---

## Appendix

### Useful Commands

```bash
# Development
gravity dev --ui ui --file main.gravity --verbose

# Validation
gravity check ui/main.gravity

# Testing
cargo test --workspace
cargo test -p gravity-core -- widget_parsing
cargo test -p gravity-iced -- widget_rendering

# Benchmarking
cargo bench -p gravity-core
cargo bench -p gravity-iced

# Linting
cargo clippy --workspace -- -D warnings
cargo fmt --all -- --check

# Examples
cd examples/todo-app && cargo run
cd examples/widget-showcase && cargo run
```

### References

- [Iced ComboBox Docs](https://docs.rs/iced/latest/iced/widget/combo_box/)
- [Iced PickList Docs](https://docs.rs/iced/latest/iced/widget/pick_list/)
- [Iced Canvas Docs](https://docs.rs/iced/latest/iced/widget/canvas/)
- [Iced ProgressBar Docs](https://docs.rs/iced/latest/iced/widget/progress_bar/)
- [Iced Tooltip Docs](https://docs.rs/iced/latest/iced/widget/tooltip/)
- [Gravity Constitution](../../.specify/memory/constitution.md)
- [Gravity AGENTS.md](../../AGENTS.md)

---

**Plan Status**: ✅ COMPLETE - Ready for task generation (`/speckit.tasks`)
