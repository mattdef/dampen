# Research: Check Validation Enhancements

**Feature**: 001-check-validation-enhancements  
**Date**: 2026-01-08  
**Status**: Complete

## Decision 1: Levenshtein Distance Algorithm

**Decision**: Implement Levenshtein distance algorithm with threshold of 3 for typo suggestions

**Rationale**:
- Standard algorithm for string similarity (insertion, deletion, substitution)
- Threshold of 3 catches common typos (one wrong character = distance 1)
- Threshold prevents false positives for intentionally different names
- O(m*n) time complexity is acceptable for small attribute/handler name sets

**Implementation**:
```rust
pub fn levenshtein_distance(a: &str, b: &str) -> usize {
    // Standard dynamic programming approach
    // Early exit if distance exceeds threshold (optimization)
}
```

**Alternatives Considered**:
- *Jaro-Winkler*: Better for longer strings, but Levenshtein is more intuitive for single-word typos
- *Soundex*: Phonetic matching not appropriate for technical identifiers

---

## Decision 2: Handler Registry JSON Schema

**Decision**: Use JSON format generated by macro with this schema:

```json
[
  {
    "name": "increment",
    "param_type": null,
    "returns_command": false
  }
]
```

**Rationale**:
- Aligns with existing `#[derive(UiModel)]` macro pattern
- Simple to generate at compile time
- Supports future extensibility (metadata fields)
- Easy to load with serde_json

**Field Meanings**:
- `name`: Handler function name as referenced in XML
- `param_type`: Expected message type (null for unit/no params)
- `returns_command`: Whether handler returns Command for async operations

---

## Decision 3: Model Info JSON Schema

**Decision**: Use JSON format with this schema:

```json
[
  {
    "name": "count",
    "type_name": "i32",
    "is_nested": false,
    "children": []
  },
  {
    "name": "user",
    "type_name": "User",
    "is_nested": true,
    "children": [
      {"name": "name", "type_name": "String", "is_nested": false, "children": []},
      {"name": "age", "type_name": "i32", "is_nested": false, "children": []}
    ]
  }
]
```

**Rationale**:
- Supports nested object validation (field.user.name)
- Type information useful for future type checking
- Children array represents nested struct fields
- Simple HashSet-based lookup for validation

---

## Decision 4: Widget Attribute Schema

**Decision**: Define attribute schema per WidgetKind with categories:

- **Required**: Must be present (error if missing)
- **Optional**: May be present
- **Events**: Event handler attributes (on_click, on_change, etc.)
- **Style Attributes**: Visual styling (background, color, etc.)
- **Layout Attributes**: Positioning and sizing (width, height, etc.)

**Known Widgets and Attributes**:

| Widget | Required | Optional | Events | Style | Layout |
|--------|----------|----------|--------|-------|--------|
| Text | value | size, weight, family | common | common | common |
| Image | src | width, height, fit | common | common | common |
| Button | - | label | on_click, on_press | common | common |
| TextInput | - | placeholder, value | on_input, on_submit, on_change | common | common |
| Checkbox | - | checked, label | on_toggle | common | common |
| Radio | label, value | selected, disabled | on_select | common | common |
| Slider | - | min, max, value, step | on_change | common | common |
| Column/Row | - | - | common | common | common |
| Container | - | - | common | common | common |

**common** = inherits from common attribute sets (STYLE_COMMON, LAYOUT_COMMON, EVENTS_COMMON)

---

## Decision 5: Error Message Format

**Decision**: Structured error messages with location and suggestions:

```
Error: Unknown attribute 'on_clik' for button in main.gravity:10:5
  Did you mean 'on_click'? (distance: 1)

Error: Missing required attribute 'value' for Text in view.gravity:3:2

Error: Unknown handler 'incremnt' in app.gravity:15:8
  Available handlers: increment, decrement, setValue
```

**Format Components**:
1. Error type and description
2. File path, line, column
3. Suggestion (if applicable)
4. Additional context (available options, valid values)

---

## Decision 6: Custom Widget Attribute Configuration

**Decision**: Support custom widget attributes via JSON config file:

```json
{
  "CustomWidget": {
    "allowed_attributes": ["value", "mode", "format"]
  }
}
```

**Rationale**:
- Allows extension without code changes
- Config file approach is declarative (aligns with constitution)
- Simple to integrate with existing validation pipeline

---

## Decision 7: Validation Error Collection Strategy

**Decision**: Collect all errors before reporting (fail-tolerant mode)

**Rationale**:
- Developers fix multiple issues at once
- Better IDE/integration experience (show all problems)
- Aligns with FR-011 requirement

**Implementation**:
```rust
let mut errors: Vec<CheckError> = Vec::new();
// During validation:
errors.push(error);
// At end:
if !errors.is_empty() {
    for error in &errors {
        eprintln!("  {}", error);
    }
    return Err(errors[0]); // First error for exit code
}
```

---

## Alternatives Rejected

1. *Strict mode by default*: Rejected - breaking change for existing users
2. *XML-based configuration*: Rejected - would require parsing configuration
3. *Compile-time validation only*: Rejected - check command is for development workflow
4. *Binary format for registry*: Rejected - JSON is human-readable and debuggable
